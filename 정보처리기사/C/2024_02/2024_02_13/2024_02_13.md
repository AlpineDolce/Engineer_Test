## ✅ 전체 코드

```c
#include <stdio.h>
 
int main() {
    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int* parr[2] = {arr[1], arr[2]};
    printf("%d", parr[1][1] + *(parr[1]+2) + **parr);
    
    return 0;
}
```

---

## 🔍 한 줄씩 설명

### 🔸 `int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};`

* 3행 3열짜리 2차원 배열 `arr` 선언
* 데이터를 1부터 9까지 순서대로 넣음

| 행 | 인덱스     | 값       |
| - | ------- | ------- |
| 0 | arr\[0] | 1  2  3 |
| 1 | arr\[1] | 4  5  6 |
| 2 | arr\[2] | 7  8  9 |

즉:

```
arr[0][0] = 1, arr[0][1] = 2, arr[0][2] = 3  
arr[1][0] = 4, arr[1][1] = 5, arr[1][2] = 6  
arr[2][0] = 7, arr[2][1] = 8, arr[2][2] = 9
```

---

### 🔸 `int* parr[2] = {arr[1], arr[2]};`

* `parr`는 **int형 포인터 2개를 저장하는 배열**
* `arr[1]` → `int*` (두 번째 행 시작 주소 → 4부터 시작)
* `arr[2]` → 세 번째 행 시작 주소 → 7부터 시작

따라서:

```
parr[0] → arr[1] → {4, 5, 6}  
parr[1] → arr[2] → {7, 8, 9}
```

---

### 🔸 `printf("%d", parr[1][1] + *(parr[1]+2) + **parr);`

이제 하나씩 해석해볼게요.

---

#### ✅ `parr[1][1]`

* `parr[1]` → arr\[2] → `{7, 8, 9}`
* `parr[1][1]` → arr\[2]\[1] → `8`

✅ 결과: `8`

---

#### ✅ `*(parr[1] + 2)`

* `parr[1]` → arr\[2] → `{7, 8, 9}`
* `parr[1] + 2` → arr\[2]의 세 번째 원소
* `*(parr[1] + 2)` → arr\[2]\[2] → `9`

✅ 결과: `9`

---

#### ✅ `**parr`

* `parr[0]` → arr\[1] → `{4, 5, 6}`
* `*parr[0]` → arr\[1]\[0] → `4`
* `**parr` == `*parr[0]` → `4`

✅ 결과: `4`

---

### ✅ 최종 계산

```
parr[1][1] + *(parr[1]+2) + **parr
= 8 + 9 + 4
= 21
```

---

## 🟩 정답: `21`

---

### 📌 요약

| 표현               | 뜻           | 값    |
| ---------------- | ----------- | ---- |
| `parr[1][1]`     | arr\[2]\[1] | 8    |
| `*(parr[1] + 2)` | arr\[2]\[2] | 9    |
| `**parr`         | arr\[1]\[0] | 4    |
| 합계               | 8 + 9 + 4   | ✅ 21 |