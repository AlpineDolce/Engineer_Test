## 🔸 전체 코드 요약

```c
void func(int** arr, int size){
  for(int i=0; i<size; i++){
     *(*arr + i) = (*(*arr+i) + i) % size;
  }
}
```

* `arr`은 이중 포인터 (`int** arr`) — 배열의 주소를 간접적으로 가리킴
* `*(*arr + i)`는 배열의 `i`번째 요소에 접근하는 방식
* `(*(*arr+i) + i) % size` → i번째 값에 i를 더하고, `size`로 나눈 나머지를 다시 그 자리에 저장

---

## 📌 코드 전체 흐름

### ▶ `main()` 함수

```c
int arr[] = {3, 1, 4, 1, 5};
```

* 정수형 배열 선언
* 인덱스 기준: `arr[0] = 3`, `arr[1] = 1`, ..., `arr[4] = 5`

```c
int* p = arr;
```

* 포인터 `p`는 배열의 시작 주소를 가리킴 (`p == &arr[0]`)

```c
int** pp = &p;
```

* `pp`는 `p`의 주소, 즉 이중 포인터 (`int**`)

```c
func(pp, 5);
```

* `pp`를 `func`에 넘겨서, 배열을 가리키는 이중 포인터로 배열 값을 변경

---

## 🔍 함수 내부 작동 방식 (`func`)

```c
for(int i=0; i<size; i++){
   *(*arr + i) = (*(*arr+i) + i) % size;
}
```

하나하나 따라가볼게요. `size = 5`니까, `i = 0 ~ 4`까지 반복됩니다.

| i | 기존 값 (`arr[i]`) | 계산식                 | 결과 (`(arr[i] + i) % 5`) | 최종 arr\[i] |
| - | --------------- | ------------------- | ----------------------- | ---------- |
| 0 | 3               | (3 + 0) % 5         | 3                       | 3          |
| 1 | 1               | (1 + 1) % 5         | 2                       | 2          |
| 2 | 4               | (4 + 2) % 5         | 1                       | 1          |
| 3 | 1               | (1 + 3) % 5         | 4                       | 4          |
| 4 | 5               | (5 + 4) % 5 = 9 % 5 | 4                       | 4          |

최종 배열 상태는:

```c
arr[] = {3, 2, 1, 4, 4};
```

---

### ▶ 이후 코드

```c
num = arr[2];
printf("%d", num);
```

* `arr[2] = 1`이므로, `num = 1`
* 출력 결과는 `1`

---

## ✅ 최종 출력

```
1
```

---

## 💡 정리

* `int**`는 이중 포인터로 포인터 자체의 주소를 넘겨서 배열을 수정한 것
* 함수 안에서 배열 원소를 `(*(*arr + i))` 식으로 접근해서 수정
* 마지막에 배열의 3번째 요소(`arr[2]`)를 출력 → `1`


## ✅ 문제 핵심 코드 다시 보기

```c
int arr[] = {3, 1, 4, 1, 5};
int* p = arr;
int** pp = &p;
func(pp, 5);
```

---

## ✅ 포인터 구조 그림으로 이해

```
        ┌────────────┐
arr →   │ 3 │ 1 │ 4 │ 1 │ 5 │   ← 실제 정수 배열 (int[])
        └────────────┘
         0   1   2   3   4   ← 인덱스

p   →   arr            → 배열의 첫 번째 주소 (int*)
pp  →   &p             → p의 주소를 가리킴 (int**)
```

---

## ✅ 함수 안에서의 표현 해석

```c
*(*arr + i) = (*(*arr + i) + i) % size;
```

여기서 매개변수는 `int** arr`, 즉 `arr`는 이중 포인터입니다.

→ 그러면 `*arr`은 `int*` → `p`를 가리킴
→ `*arr + i`는 `p + i`와 같음 → `arr[i]`를 가리키는 주소
→ `*(*arr + i)`는 결국 `arr[i]` 값과 같아요!

---

### 🔁 예를 들어 `i = 2`일 때:

```c
*(*arr + 2)
↓
*(p + 2)
↓
arr[2] → 값은 4
```

---

## ✅ 함수 내부 전체 동작 요약

```c
for(int i=0; i<size; i++) {
   *(*arr + i) = (*(*arr+i) + i) % size;
}
```

### 위 코드는 이렇게 작동합니다:

1. `*arr + i` → `arr[i]` 위치
2. `*(*arr + i)` → arr\[i] 값
3. 계산: `(arr[i] + i) % size`
4. 결과를 다시 arr\[i]에 저장

---

## ✅ 각 단계별 배열 변화

| i | 기존 arr\[i] | 계산              | 결과 |
| - | ---------- | --------------- | -- |
| 0 | 3          | (3 + 0) % 5 = 3 | 3  |
| 1 | 1          | (1 + 1) % 5 = 2 | 2  |
| 2 | 4          | (4 + 2) % 5 = 1 | 1  |
| 3 | 1          | (1 + 3) % 5 = 4 | 4  |
| 4 | 5          | (5 + 4) % 5 = 4 | 4  |

➡ 최종 배열: `[3, 2, 1, 4, 4]`

---

## ✅ 전체 포인터 흐름 정리

| 표현               | 의미                       |
| ---------------- | ------------------------ |
| `arr`            | 배열 이름 → 배열 첫 요소 주소       |
| `p = arr`        | `p`가 배열 첫 번째 요소 가리킴      |
| `pp = &p`        | `pp`는 `p`의 주소 (즉 이중 포인터) |
| `*arr` (in func) | `p`를 가리킴 (`int*`)        |
| `*(*arr + i)`    | `arr[i]` 값               |

---

## ✅ 헷갈릴 때 이렇게 기억하세요!

```c
int arr[] = {3, 1, 4, 1, 5};
int* p = arr;
int** pp = &p;
```

| 표현            | 의미                   |
| ------------- | -------------------- |
| `arr`         | 배열의 첫 요소 주소 (`int*`) |
| `p`           | 배열 전체를 가리키는 포인터      |
| `*arr + i`    | `p + i` 와 같음         |
| `*(*arr + i)` | `*(p + i)` → arr\[i] |

---

## ✅ 혹시 헷갈린다면?

이해에 도움이 되도록 다음 그림으로 기억하세요:

```
pp → p → arr → [3][1][4][1][5]
                 ↑
               arr[0]
```