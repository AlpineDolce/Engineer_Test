### 코드 분석

```c
#include <stdio.h>
char Data[5] = {'B', 'A', 'D', 'E'};
char c;
```

1. **헤더 파일 `#include <stdio.h>`**:
    - 표준 입출력 라이브러리로, `printf`와 같은 출력 함수 등을 사용할 수 있게 해줌.
2. **`char Data[5] = {'B', 'A', 'D', 'E'};`**:
    - `Data`라는 **문자형 배열**을 선언하고 초기화. 배열은 총 5개의 요소를 저장할 수 있지만, 4개의 문자만 넣었고 마지막에는 아무 값도 안 들어 있어. C에서는 빈 요소는 기본적으로 `'\0'` (NULL 문자)로 채워짐.
    - 배열은 이렇게 초기화됨:
        
        ```c
        Data[0] = 'B'; // 첫 번째 요소
        Data[1] = 'A'; // 두 번째 요소
        Data[2] = 'D'; // 세 번째 요소
        Data[3] = 'E'; // 네 번째 요소
        Data[4] = '\0'; // 다섯 번째 요소는 자동으로 NULL로 채워짐
        
        ```
        
3. **`char c;`**:
    - 문자형 변수 `c`를 선언. 이후 코드에서 이 변수에 `'C'`라는 값이 할당됨.

---

### 메인 함수 (`main` 함수) 분석

```c
int main(){
    int i, temp, temp2;
```

- `i`, `temp`, `temp2`는 **정수형 변수**들로, 반복문을 제어하거나 값을 임시로 저장하는 데 사용될 거야.

---

### 첫 번째 출력 (`printf`)

```c
c = 'C';
printf("%d\n", Data[3] - Data[1]);
```

1. **`c = 'C';`**: 변수 `c`에 문자 `'C'`를 할당.
2. **`printf("%d\n", Data[3] - Data[1]);`**:
    - `Data[3]`는 `'E'`이고, `Data[1]`은 `'A'`야.
    - 문자 `'E'`와 `'A'`의 **아스키 코드** 값을 뺀 결과를 출력.
        - `'E'`의 아스키 코드 값은 69, `'A'`는 65이므로:
        - `69 - 65 = 4`가 출력돼.

**출력**: `4`

---

### 두 번째 반복문 (`for` loop)

```c
for(i = 0; i < 5; ++i){
    if(Data[i] > c)
        break;
}
```

1. **`for(i = 0; i < 5; ++i)`**: `i`가 0부터 4까지 반복되는 **for문**.
2. **`if(Data[i] > c)`**: `Data[i]`의 값이 변수 `c`(`'C'`)보다 **큰 문자**가 나타나면 `break`로 반복문을 종료.
    - `Data[0] = 'B'`, `'B'`는 `'C'`보다 작으므로 계속 진행.
    - `Data[1] = 'A'`, `'A'`도 `'C'`보다 작으므로 계속 진행.
    - `Data[2] = 'D'`, `'D'`는 `'C'`보다 크므로 **`if` 조건이 참**이 되고, **반복문이 종료**됨.

**결과적으로 `i`의 값은 2**가 됨.

---

### 데이터 스왑 및 배열 변경

```c
temp = Data[i];
Data[i] = c;
i++;
```

1. `temp = Data[i];`:
    - `i`는 2였으므로 `Data[2]`의 값인 `'D'`를 `temp`에 저장.
2. `Data[i] = c;`:
    - `Data[2]`에 `'C'`를 넣어, `Data[2]`가 `'C'`로 변경됨.
3. `i++;`:
    - `i`의 값을 3으로 증가시킴.

**결과**:

- `Data[2]`는 `'C'`로 변경됨.
- `i`는 3이 됨.

---

### 세 번째 반복문 (스왑)

```c
for(; i < 5; ++i){
    temp2 = Data[i];
    Data[i] = temp;
    temp = temp2;
}
```

1. `for(; i < 5; ++i)`:
    - `i`는 3에서 시작하므로, `i`가 5보다 작은 동안 반복됨.
2. **스왑 과정**:
    - `temp2 = Data[i];`에서 `Data[i]` 값을 `temp2`에 저장.
    - `Data[i] = temp;`에서 `Data[i]`에 `temp` 값을 넣음.
    - 마지막으로 `temp = temp2;`로 `temp` 값을 업데이트.
    - 이 과정은 배열에서 값을 차례대로 밀어내는 역할을 함.

**세부 과정**:

- **첫 번째 반복**: `i = 3`
    - `temp2 = Data[3]` → `'E'`
    - `Data[3] = temp` → `Data[3] = 'D'`
    - `temp = 'E'`
- **두 번째 반복**: `i = 4`
    - `temp2 = Data[4]` → `'\0'`
    - `Data[4] = temp` → `Data[4] = 'E'`
    - `temp = '\0'`

**결과**:

- 배열의 값들이 **밀려서** `'C'`와 `'D'`가 자리 바꿈됨.

---

### 마지막 출력

```c
for(i = 0; i < 5; i++){
    printf("%c", Data[i]);
}
```

- **`for(i = 0; i < 5; i++)`**: 배열의 모든 요소를 출력하는 반복문.
- `printf("%c", Data[i]);`는 배열의 **각 문자**를 출력.

최종 배열 `Data`는 `{'B', 'A', 'C', 'D', 'E'}`이고, 이를 출력하면:

**출력**: `BACDE`

---

### **최종 출력 결과**

```
4
BACDE
```

---

### **전체 흐름 요약**

1. **첫 번째 출력**: `Data[3] - Data[1]` 계산 → `4`
2. **첫 번째 `for`문**: `Data[i] > c`를 체크하며 `i`는 `2`에서 멈춤.
3. **값 교환**:
    - `Data[2]`에 `'C'` 넣기.
    - `i++` 후, `Data[3]`, `Data[4]` 값 밀기.
4. **두 번째 출력**: 배열의 모든 값 출력 → `BACDE`