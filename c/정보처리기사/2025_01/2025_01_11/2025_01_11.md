# 📘 1. `#include <stdio.h>`

> C에서 기본 입출력 함수(예: printf)를 사용하기 위한 헤더파일
> 
- `stdio.h`는 **Standard Input/Output**의 줄임말
- `printf`, `scanf` 등 기본 입출력 함수들이 이 안에 정의돼 있음

---

# 📘 2. `#include <stdlib.h>`

> 동적 메모리 할당 함수 (malloc, free) 등 사용을 위한 헤더파일
> 
- `stdlib.h`는 **Standard Library**의 줄임말
- `malloc`, `calloc`, `realloc`, `free`, `atoi`, `rand` 등 다양한 함수 포함

---

# 📘 3. `void set(int** arr, int* data, int rows, int cols)`

> arr이라는 2차원 배열에 1차원 배열 data를 특정 순서로 채우는 함수 선언
> 
- `int** arr`: 2차원 배열 (포인터의 포인터)
- `int* data`: 1차원 배열
- `int rows`: 행의 개수 (3)
- `int cols`: 열의 개수 (3)
- `void`: 이 함수는 값을 반환하지 않음

---

## 📘 4. `for (int i = 0; i < rows * cols; ++i)`

> data 배열의 모든 요소(9개)를 한 번씩 처리하기 위한 반복문
> 
- `rows * cols = 3 * 3 = 9` → 9개의 값을 처리해야 함
- `i`는 0부터 8까지 반복됨

---

## 📘 5. `arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];`

이 줄이 좀 까다로움. 해부해보자.

```c
int row = ((i + 1) / rows) % rows;
int col = (i + 1) % cols;
arr[row][col] = data[i];
```

### 👇 예시로 직접 계산 (i = 0부터 8까지)

| i | i+1 | row= ((i+1)/3)%3 | col= (i+1)%3 | data[i] | arr[row][col] |
| --- | --- | --- | --- | --- | --- |
| 0 | 1 | 0 | 1 | 5 | arr[0][1] = 5 |
| 1 | 2 | 0 | 2 | 2 | arr[0][2] = 2 |
| 2 | 3 | 1 | 0 | 7 | arr[1][0] = 7 |
| 3 | 4 | 1 | 1 | 4 | arr[1][1] = 4 |
| 4 | 5 | 1 | 2 | 1 | arr[1][2] = 1 |
| 5 | 6 | 2 | 0 | 8 | arr[2][0] = 8 |
| 6 | 7 | 2 | 1 | 3 | arr[2][1] = 3 |
| 7 | 8 | 2 | 2 | 6 | arr[2][2] = 6 |
| 8 | 9 | 3 % 3 = 0 | 0 | 9 | arr[0][0] = 9 |

➡️ 최종 배열 `arr` 상태:

```
[9, 5, 2]
[7, 4, 1]
[8, 3, 6]
```

---

# 🔹 이제 `main()` 시작

---

## 📘 6. `int main() {`

- 프로그램 시작점

---

## 📘 7. `int rows = 3, cols = 3, sum = 0;`

- `rows`: 행 수 (3)
- `cols`: 열 수 (3)
- `sum`: 합계 저장용 변수. 초기값 0

---

## 📘 8. `int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};`

- 크기 9짜리 정수형 배열
- `data[0] = 5`, `data[1] = 2`, ..., `data[8] = 9`

---

## 📘 9. `int** arr;`

- 이중 포인터 (포인터를 가리키는 포인터)
- 나중에 동적으로 2차원 배열처럼 쓸 예정

---

## 📘 10. `arr = (int**) malloc(sizeof(int*) * rows);`

> 🔧 핵심: "3개의 포인터를 담을 메모리 확보"
> 
- `sizeof(int*)` → 포인터 하나의 크기 (보통 8바이트)
- `rows = 3` → 포인터 3개
- `malloc(sizeof(int*) * 3)` → 24바이트 확보
- `(int**)` → malloc은 `void*` 리턴하므로 형변환

🔎 결국 `arr[0]`, `arr[1]`, `arr[2]`를 가리킬 수 있게 됨

---

## 📘 11. `for (int i = 0; i < cols; i++) { ... }`

- 각 행마다 열을 할당하기 위한 반복문

---

### 📘 12. `arr[i] = (int*) malloc(sizeof(int) * cols);`

> 각 행마다 정수 3개짜리 공간 확보
> 
- `sizeof(int)` → 보통 4바이트
- `cols = 3` → 정수 3개
- `malloc(4 * 3)` → 12바이트
- `(int*)` → 정수 포인터로 형변환

총 3번 반복됨 → 3x3 배열 구조 완성

---

## 📘 13. `set(arr, data, rows, cols);`

- 만든 2차원 배열에 `data` 값을 채워넣음

---

## 📘 14. `for (int i = 0; i < rows * cols; i++) { ... }`

- 총 9개의 배열 값을 순회하면서 합계 계산

---

### 📘 15. `sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);`

- `i / rows` → 현재 행
- `i % cols` → 현재 열
- `(i % 2 == 0 ? 1 : -1)` → i가 짝수면 +1, 홀수면 -1

📌 ➕ 짝수 번째는 더하고 ➖ 홀수 번째는 뺌

이 구문은 **짝수 인덱스는 더하고, 홀수 인덱스는 빼는 구조**입니다.

| i | i / 3 | i % 3 | arr[row][col] | 홀/짝 | 부호 | 누적 합계 |
| --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 9 | 짝수 | +1 | 9 |
| 1 | 0 | 1 | 5 | 홀수 | -1 | 4 |
| 2 | 0 | 2 | 2 | 짝수 | +1 | 6 |
| 3 | 1 | 0 | 7 | 홀수 | -1 | -1 |
| 4 | 1 | 1 | 4 | 짝수 | +1 | 3 |
| 5 | 1 | 2 | 1 | 홀수 | -1 | 2 |
| 6 | 2 | 0 | 8 | 짝수 | +1 | 10 |
| 7 | 2 | 1 | 3 | 홀수 | -1 | 7 |
| 8 | 2 | 2 | 6 | 짝수 | +1 | **13** |

---

## 📘 16. `for (int i = 0; i < rows; i++) { free(arr[i]); }`

- 각 행의 메모리를 해제

---

## 📘 17. `free(arr);`

- 행을 가리키던 포인터 배열도 해제

---

## 📘 18. `printf("%d", sum);`

- 최종 계산된 결과(sum)를 출력

---

# ✅ 최종 출력 결과

```
13
```

---

# 🎓 정리 요약표

| 개념 | 설명 |
| --- | --- |
| `malloc(size)` | 메모리를 실행 중에 동적으로 할당하는 함수 |
| `sizeof(type)` | 특정 자료형 또는 변수의 크기를 바이트 단위로 계산 |
| `int**` | 2차원 배열처럼 사용할 수 있는 포인터의 포인터 |
| `free(ptr)` | `malloc`으로 확보한 메모리를 해제하는 함수 |
| `arr[i][j]` | 이중 포인터(`int**`)를 통해 2차원 배열처럼 값에 접근 |
| `(i % 2 == 0 ? 1 : -1)` | 삼항 연산자: `i`가 짝수면 1을 곱하고, 홀수면 -1을 곱함 |